\documentclass[11pt, a4paper]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[italian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{makeidx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{varwidth}
\usetikzlibrary{shapes.geometric, arrows}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

%for code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=VHDL,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  backgroundcolor=\color{white}
}

\title{Progetto di Reti Logiche}
\author{
  William Zeni\\
  \texttt{matricola 10613915}
  \and
  Cristina Urso\\
  \texttt{matricola 10599689}
}

\date{Anno 2020/21}

\graphicspath{ {./graphics/} }

\makeindex

\begin{document}

\begin{figure}[t]
  \centering
  \vspace{3cm}
  \includegraphics[scale=0.4]{Logo_Politecnico_Milano.png}
  \vspace{3cm}
\end{figure}

\maketitle
\renewcommand{\abstractname}{ }
\begin{abstract}
  \centering
  Progetto sostenuto presso il Politecnico di Milano - Dipartimento di Elettronica, Informazione e Bioingegneria. Corso diretto dal Prof. Gianluca Palermo.
\end{abstract}

\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}
\pagebreak
\pagenumbering{arabic}


\section{Introduzione}
\subsection{Scopo del progetto}
Lo scopo del progetto è quello di creare un componente hardware sintetizzabile, in grado di equalizzare un immagine. L'algoritmo che ne prevede l'equalizzazione si ispira ad una versione semplificata del metodo di equalizzazione dell'istogramma, il quale prevede un aumento nel contrasto di un immagine su scala di grigi. In generale l'elaborazione digitale dell'immagine risulta più evidente specialmente quando i dati raccolti sono rappresentati da valori di intensità molto vicini. Per cui, se una immagine contenesse una scala di grigi molto ampia, l'effeto dell'equalizzazione risulterebbe pressochè nullo.

\subsection{Specifiche generali}
Si definisca un immagine dalle dimensioni variabili, ma di massimo $128 \times 128$, e si definisca una memoria lineare nella quale i primi due valori siano le dimensioni dell'immagine e i restanti i valori assegnati ad ogni pixel, il componente hardware dovrà scrivere in coda alla memoria l'immagine equalizzata pixel per pixel.
Il risultato sarà una memoria complessivamente lunga $2 \cdot N_{col} \cdot N_{row} +2$, dove $N_{row}$ e $N_{col}$ sono rispettivamente il numero di righe e di colonne dell'immagine. A partire dalla posizione 2, per ogni pixel si avrà il corrispettivo pixel equalizzato ad una distanza $N_{col} \cdot N_{row}$ come mostrato in figura.
\\
\\

\begin{tikzpicture}
\draw[step=1cm, black,very thin] (0,0) grid (13,1);
\fill[text=black] (0.5,0.5) node{$N_{col}$};
\fill[text=black] (0.5,1.3) node{$0$};
\fill[text=black] (1.5,0.5) node{$N_{row}$};
\fill[text=black] (1.5,1.3) node{$1$};
\fill[blue!30!white, draw=black] (2,0) rectangle (3,1);
\fill[text=black] (2.5,1.3) node{$2$};
\fill[green!30!white, draw=black] (3,0) rectangle (4,1);
\fill[text=black] (3.5,1.3) node{$3$};
\fill[red!30!white, draw=black] (4,0) rectangle (5,1);
\fill[text=black] (4.5,1.3) node{$4$};
\fill[text=black] (5.5,0.5) node{\dots};
\fill[text=black] (6.5,0.5) node{\dots};
\fill[text=black] (7.5,0.5) node{\dots};
\fill[blue!30!white, draw=black] (8,0) rectangle (9,1);
\fill[text=black] (8.5,1.3) node{$N_{col}\cdot N_{row}+2$};
\fill[text=black] (8.5,-0.5) node{\texttt{new\_pixel}};
\fill[green!30!white, draw=black] (9,0) rectangle (10,1);
\fill[red!30!white, draw=black] (10,0) rectangle (11,1);
\fill[text=black] (11.5,0.5) node{\dots};
\end{tikzpicture}
\\
La memoria dialogherà in stretto contatto con il componente attraverso due segnali, che determineranno l'avvio della computazione, la sua terminazione e l'eventuale ripartenza. Si noti che la computazione di un immagine, una volta iniziata, non potrà mai essere interrotta, ma rimane possibile la computazione di più immagini.\\
\\
Ogni pixel avrà un valore compreso tra $0$ e $255$ e verrà rielaborato dal componente nel seguente modo:\\
\\

\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

\begin{algorithmic}[1]
  \State $delta\_value \gets max\_pixel\_value - min\_pixel\_value$
  \State $shift\_level \gets 8 - \floor{\log_2(delta\_value+1)}$
  \State $temp\_pixel \gets curr\_pixel\_value - min\_pixel\_value$
  \State $temp\_pixel \gets temp\_pixel << shift\_level$
  \If{$temp\_pixel > 255$}
    \State $new\_pixel \gets 255$
  \Else
    \State $new\_pixel \gets temp\_pixel$
  \EndIf
\end{algorithmic}

\end{varwidth}
}
\\
\\
\\
dove \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} sono rispettivamente il valore massimo e il valore minimo del pixel trovati all'interno dell'immagine, \texttt{curr\_pixel\_value} è il valore del pixel preso in considerazione e \texttt{new\_pixel} è il valore del pixel da scrivere in memoria.
\pagebreak



\subsection{Interfaccia del componente}
\begin{lstlisting}
entity project_reti_logiche is
port (
    i_clk       : in std_logic;
    i_rst       : in std_logic;
    i_start     : in std_logic;
    i_data      : in std_logic_vector(7 downto 0);
    o_address   : out std_logic_vector(15 downto 0);
    o_done      : out std_logic;
    o_en        : out std_logic;
    o_we        : out std_logic;
    o_data      : out std_logic_vector (7 downto 0)
);
end project_reti_logiche;
\end{lstlisting}
L'interfaccia del componente, per potersi relazionare con la memoria, deve essere come quella sopra riportata. I segnali di input vengono evidenziati dal prefisso \texttt{\lq i\_'}, mentre per i segnali di output è presente il prefisso \texttt{\lq o\_'}. Nel dettaglio:
\begin{itemize}
  \item \textbf{i\_clk} scandisce il ciclo di clock della memoria, registrando $1$ sul \texttt{rising\_edge}.
  \item \textbf{i\_rst}
  \item \textbf{i\_start}
  \item \textbf{i\_data}
  \item \textbf{o\_address}
  \item \textbf{o\_done}
  \item \textbf{o\_en}
  \item \textbf{o\_we}
  \item \textbf{o\_data}
\end{itemize}

\subsection{Dati e Descrizione memoria}
Write somenthing here

\pagebreak
\section{Desing Pattern}
\subsection{Scelte Progettuali}
La struttura del progetto è stata suddivisa in due process principali: \texttt{UPDATE} e \texttt{STATES}.
Il primo ha il compito di relazionarsi con la memoria e il secondo contiene gli stati della macchina impiegati nella equalizzazione delle immagini. In questo modo una porzione di codice è adibita esclusivamente alla computazione dei pixel (process \texttt{STATES}), mentre la rimanente si occupa dei segnali di output della \textit{entity} (process \texttt{UPDATE}).
Per permette un corretto dialogo tra i due process è nata l'esigenza di avere dei segnali ``duplicati".
I segnali con suffisso \texttt{\lq\_cp'} sono stati introdotti per mantere in memoria i valori computati, mentre i segnali con suffisso \texttt{\lq\_next'} sono stati implementati allo scopo di permettere agli stati di far richieste alla memoria.
Nel particolare, per ogni ciclo di clock, durante \textit{rising\_edge}, il process \texttt{UPDATE} si risveglia, aggiornando i segnali. I segnali contenenti i valori da mantenere vengono reimpostati con i segnali \texttt{\lq\_cp'}, mentre i segnali di output della \textit{entity} sono aggiornati con i segnali \texttt{\lq\_next'}.


\subsection{Elenco Stati}

\subsubsection{START}
Lo stato di \texttt{START} è stato pensato come stato di attesa iniziale. Questo stato viene invocato in due situazioni differenti: se il segnale di \texttt{i\_rst} viene portato alto, oppure quando il segnale \texttt{i\_start} viene riportato basso dopo la computazione di un immagine. Lo stato \texttt{START} non cambia fino a quando il segnale \texttt{i\_start} non viene portato alto. In quel momento lo stato successivo viene impostato \texttt{INIT}.

\subsubsection{INIT}
Lo stato \texttt{INIT} è uno stato di transizione nel quale il processore si assicura che i segnali siano inizializzati con i valori opportuni. Successivamente imposta lo stato prossimo a \texttt{ABILIT\_READ}.

\subsubsection{ABILIT\_READ}
Lo stato \texttt{ABILIT\_READ} è lo stato attraverso il quale abilitiamo la memoria alla sola lettura. Viene richiamato in momenti diversi del progetto e, in base allo stato chiamante, instrada lo stato prossimo a quello opportuno.

\subsubsection{ABILIT\_WRITE}
Lo stato \texttt{ABILIT\_WRITE} abilita la memoria alla scrittura. Viene invocato subito dopo aver computato il valore del nuovo pixel e in nessun altro momento. Instrada poi lo stato prossimo a \texttt{WRITE\_PIXEL}.

\subsubsection{WAIT\_MEM}
Lo stato \texttt{WAIT\_MEM} è uno stato centrale durante la gestione del flusso di dati. Sostanzialmente ``spreca" un ciclo di clock. Questo ci assicura sia in caso di scrittura, sia in caso di lettura, che i segnali in ingresso e in uscita siano letti o scritti correttamente. Nel caso specifico alla quale ci rifacciamo, alcune chiamate a questo stato potevano essere evitate. Questa informazione è emersa durante lo stress test a cui il processore è stato sottoposto. Tuttavia, si è preferito lasciarle per mantenere la stuttura del processore. Ciò dovrebbe permette una maggior robustezza, sebbene un aumento nella latenza della computazione.

\subsubsection{GET\_RC}
Lo stato \texttt{GET\_RC} è uno stato in preparazione al calcolo della dimensione dell'immagine e dei punti in cui bisognerà scrivere all'interno della memoria. Lo stato \texttt{GET\_RC} viene invocato dopo l'abilitazione della memoria alla lettura. Questo stato si occupa del recuperare i valori dalla memoria e aggiornare i segnali \texttt{n\_col} e \texttt{n\_row}.

\subsubsection{GET\_DIM}
Lo stato \texttt{GET\_DIM} è lo stato che si preoccupa di aggiornare il segnale \texttt{dim\_address} con il valore opportuno. Il calcolo $n\_col \cdot n\_row + 2$ aggiorna il segnale al primo bit libero per la scrittura.


\subsubsection{READ\_PIXEL}
Lo stato \texttt{READ\_PIXEL} è uno stato strettamente accopiato con lo stato \texttt{GET\_MINMAX}. Richiede alla memoria il valore del pixel e aggiorna il segnale \texttt{curr\_address} a quello successivo. In questo modo il valore del pixel sarà disponibile sul segnale \texttt{i\_data} al \textit{rising\_edge} successivo.

\subsubsection{GET\_MINMAX}
Write somenthing here.

\subsubsection{GET\_DELTA}
Write somenthing here

\subsubsection{CALC\_SHIFT}
Write somenthing here

\subsubsection{GET\_PIXEL}
Write somenthing here

\subsubsection{CALC\_NEWPIXEL}
Write somenthing here

\subsubsection{WRITE\_PIXEL}
Write somenthing here.

\subsubsection{DONE}
Write somenthing here

\subsubsection{WAITINGPIC}
Write somenthing here

\section{Risultati dei Test}
Write somenthing here!

\section{Conclusioni}
Write somenthing here

\end{document}
