\documentclass[11pt, a4paper]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[italian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{float}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{makeidx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{varwidth}
\usetikzlibrary{automata, positioning, decorations.text, topaths, arrows.meta, decorations.pathmorphing, quotes, shapes.geometric, arrows}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\tikzset{
->, % makes the edges directed
%>=stealth’, % makes the arrow heads bold
node distance=1cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

%for code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=VHDL,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  backgroundcolor=\color{white}
}

\title{Progetto di Reti Logiche}
\author{
  William Zeni\\
  \texttt{matricola 10613915}
  \and
  Cristina Urso\\
  \texttt{matricola 10599689}
}

\date{Anno 2020/21}

\graphicspath{ {./graphics/} }

\makeindex

\begin{document}

\begin{figure}[t]
  \centering
  \vspace{3cm}
  \includegraphics[scale=0.4]{Logo_Politecnico_Milano.png}
  \vspace{3cm}
\end{figure}

\maketitle
\renewcommand{\abstractname}{ }
\begin{abstract}
  \centering
  Progetto sostenuto presso il Politecnico di Milano - Dipartimento di Elettronica, Informazione e Bioingegneria. Corso diretto dal Prof. Gianluca Palermo.
\end{abstract}

\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}
\pagebreak
\pagenumbering{arabic}


\section{Introduzione}
\subsection{Scopo del progetto}
Lo scopo del progetto è quello di creare un componente hardware sintetizzabile, in grado di equalizzare un immagine. L'algoritmo che ne prevede l'equalizzazione si ispira ad una versione semplificata del metodo di equalizzazione dell'istogramma, il quale prevede un aumento nel contrasto di un immagine su scala di grigi. In generale l'elaborazione digitale dell'immagine risulta più evidente specialmente quando i dati raccolti sono rappresentati da valori di intensità molto vicini. Per cui, se una immagine contenesse una scala di grigi molto ampia, l'effeto dell'equalizzazione risulterebbe pressochè nullo.

\subsection{Specifiche generali}
Si definisca un immagine dalle dimensioni variabili, ma di massimo $128 \times 128$, e si definisca una memoria lineare nella quale i primi due valori siano le dimensioni dell'immagine e i restanti i valori assegnati ad ogni pixel, il componente hardware dovrà scrivere in coda alla memoria l'immagine equalizzata pixel per pixel.
Il risultato sarà una memoria complessivamente lunga $2 \cdot N_{col} \cdot N_{row} +2$, dove $N_{row}$ e $N_{col}$ sono rispettivamente il numero di righe e di colonne dell'immagine. A partire dalla posizione 2, per ogni pixel si avrà il corrispettivo pixel equalizzato ad una distanza $N_{col} \cdot N_{row}$ come mostrato in figura.
\\
\\

\begin{tikzpicture}
\draw[step=1cm, black,very thin] (0,0) grid (13,1);
\fill[text=black] (0.5,0.5) node{$N_{col}$};
\fill[text=black] (0.5,1.3) node{$0$};
\fill[text=black] (1.5,0.5) node{$N_{row}$};
\fill[text=black] (1.5,1.3) node{$1$};
\fill[blue!30!white, draw=black] (2,0) rectangle (3,1);
\fill[text=black] (2.5,1.3) node{$2$};
\fill[green!30!white, draw=black] (3,0) rectangle (4,1);
\fill[text=black] (3.5,1.3) node{$3$};
\fill[red!30!white, draw=black] (4,0) rectangle (5,1);
\fill[text=black] (4.5,1.3) node{$4$};
\fill[text=black] (5.5,0.5) node{\dots};
\fill[text=black] (6.5,0.5) node{\dots};
\fill[text=black] (7.5,0.5) node{\dots};
\fill[blue!30!white, draw=black] (8,0) rectangle (9,1);
\fill[text=black] (8.5,1.3) node{$N_{col}\cdot N_{row}+2$};
\fill[text=black] (8.5,-0.5) node{\texttt{new\_pixel}};
\fill[green!30!white, draw=black] (9,0) rectangle (10,1);
\fill[red!30!white, draw=black] (10,0) rectangle (11,1);
\fill[text=black] (11.5,0.5) node{\dots};
\end{tikzpicture}
\\
La memoria dialogherà in stretto contatto con il componente attraverso due segnali, che determineranno l'avvio della computazione, la sua terminazione e l'eventuale ripartenza. Si noti che la computazione di una singola immagine, una volta iniziata, non potrà mai essere interrotta, ma rimane possibile la computazione di più immagini.\\
\\
Ogni pixel avrà un valore compreso tra $0$ e $255$ e verrà rielaborato dal componente nel seguente modo:\\
\\

\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

\begin{algorithmic}[1]
  \State $delta\_value \gets max\_pixel\_value - min\_pixel\_value$
  \State $shift\_level \gets 8 - \floor{\log_2(delta\_value+1)}$
  \State $temp\_pixel \gets curr\_pixel\_value - min\_pixel\_value$
  \State $temp\_pixel \gets temp\_pixel << shift\_level$
  \If{$temp\_pixel > 255$}
    \State $new\_pixel \gets 255$
  \Else
    \State $new\_pixel \gets temp\_pixel$
  \EndIf
\end{algorithmic}

\end{varwidth}
}
\\
\\
\\
dove \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} sono rispettivamente il valore massimo e il valore minimo del pixel trovati all'interno dell'immagine, \texttt{curr\_pixel\_value} è il valore del pixel preso in considerazione e \texttt{new\_pixel} è il valore del pixel da scrivere in memoria.
\pagebreak

\subsection{Interfaccia del componente}
\begin{lstlisting}
entity project_reti_logiche is
port (
    i_clk       : in std_logic;
    i_rst       : in std_logic;
    i_start     : in std_logic;
    i_data      : in std_logic_vector(7 downto 0);
    o_address   : out std_logic_vector(15 downto 0);
    o_done      : out std_logic;
    o_en        : out std_logic;
    o_we        : out std_logic;
    o_data      : out std_logic_vector (7 downto 0)
);
end project_reti_logiche;
\end{lstlisting}
L'interfaccia del componente, per potersi relazionare con la memoria, deve essere come quella sopra riportata. I segnali di input vengono evidenziati dal prefisso \texttt{\lq i\_'}, mentre per i segnali di output è presente il prefisso \texttt{\lq o\_'}. Nel dettaglio:
\begin{itemize}
  \item \textbf{i\_clk} scandisce il ciclo di clock della memoria, registrando \lq$1$' sul \texttt{rising\_edge}.
  \item \textbf{i\_rst} è il segnale di \texttt{RESET}, viene chiamato all'inizio della computazione di una o più immagini. Se si registra \lq$1$' su questo segnale la computazione deve essere terminata e ripristinata al momento di partenza.
  \item \textbf{i\_start} determina l'inizio della coputazione. Questo segnale rimane alto fino a quando la computazione non termina. La computazione può iniziare solo se il segnale è basso.
  \item \textbf{i\_data} raccoglie i dati inviati dalla memoria.
  \item \textbf{o\_address} è il segnale attraverso il quale facciamo richieste alla memoria. Sostanzialmente su questo segnale si pone l'indirizzo della memoria che si vuuole leggere o sulla quale si vuole scrivere.
  \item \textbf{o\_done} determina la fine della computazione. Il segnale deve essere portato alto quando si vuole terminare la computazione e deve rimanere alto fino a quando la memoria non porti il segnale di \texttt{START} basso. Solo in quel caso il segnale viene riportato basso.
  \item \textbf{o\_en} abilita la memoria alla lettura o alla scrittura.
  \item \textbf{o\_we}  abilita la memoria alla scrittura. Quando questo segnale è alto la memoria si aspetta un dato in ingresso da scrivere.
  \item \textbf{o\_data} è il dato che la memoria si aspetta di leggere quando la scrittura è attiva.
\end{itemize}
\pagebreak
\subsection{Dati e Descrizione memoria}
Write somenthing here

\pagebreak
\section{Desing Pattern}
\subsection{Scelte Progettuali}
La struttura del progetto è stata suddivisa in due process principali: \texttt{UPDATE} e \texttt{STATES}.
Il primo ha il compito di relazionarsi con la memoria e il secondo contiene gli stati della macchina impiegati nella equalizzazione delle immagini. In questo modo una porzione di codice è adibita esclusivamente alla computazione dei pixel (process \texttt{STATES}), mentre la rimanente si occupa dei segnali di output della \textit{entity} (process \texttt{UPDATE}).\\
Per permette un corretto dialogo tra i due process è nata l'esigenza di avere dei segnali ``duplicati".
I segnali con suffisso \texttt{\lq\_cp'} sono stati introdotti per mantere in memoria i valori computati, mentre i segnali con suffisso \texttt{\lq\_next'} sono stati implementati allo scopo di permettere agli stati di far richieste alla memoria.
Nel particolare, per ogni ciclo di clock, durante il \textit{rising\_edge}, il process \texttt{UPDATE} si risveglia, aggiornando i segnali. I segnali contenenti i valori da mantenere vengono reimpostati con i segnali \texttt{\lq\_cp'}, mentre i segnali di output della \textit{entity} sono aggiornati con i segnali \texttt{\lq\_next'}.

Il succo della computazione è trattunuto dal process \texttt{STATES}, che è a tutti gli effetti un \texttt{FSA} (\textit{Macchina a Stati Finiti}) rappresentabile attraverso lo schema al paragrafo $2.3$.
Il suo funzionamento è permesso sostanzialmente da tre segnali a lui dedicati: \texttt{next\_state}, che identifica la chiamata allo stato prossimo,  \texttt{curr\_state}, che rileva lo stato corrente, e \texttt{prev\_state}, che conserva lo stato precedente.

\subsection{Elenco Stati}

\subsubsection{START}
Lo stato di \texttt{START} è il primo stato del process \texttt{STATES} ed è stato pensato come stato di attesa iniziale. Questo stato viene invocato in due situazioni differenti: se il segnale di \texttt{i\_rst} viene portato alto, oppure quando il segnale \texttt{i\_start} viene riportato basso dopo la computazione di un immagine. Lo stato \texttt{START} non cambia fino a quando il segnale \texttt{i\_start} non viene portato alto. In quel momento lo stato successivo viene impostato \texttt{INIT}.

\subsubsection{INIT}
\texttt{INIT} è uno stato di transizione nel quale il processore si assicura che i segnali siano inizializzati con i valori opportuni. Successivamente imposta lo stato prossimo a \texttt{ABILIT\_READ}.

\subsubsection{ABILIT\_READ}
Attraverso \texttt{ABILIT\_READ} si abilita la memoria alla sola lettura. Viene richiamato in due momenti diversi del progetto: all'inizio della computazione, subito dopo \texttt{INIT}, per portare il segnale \texttt{o\_en} a $1$ e permettere agli altri stati di poter leggere dalla memoria, oppure dopo la scrittura di un pixel, al fine di disabilitare l'accesso alla scrittura. In base allo stato chiamante, instrada lo stato prossimo a quello opportuno.

\subsubsection{ABILIT\_WRITE}
Lo stato \texttt{ABILIT\_WRITE} abilita la memoria alla scrittura. Viene invocato subito dopo aver computato il valore del nuovo pixel e in nessun altro momento. Instrada poi lo stato prossimo a \texttt{WRITE\_PIXEL}.

\pagebreak
\subsubsection{WAIT\_MEM}
\texttt{WAIT\_MEM} è uno stato centrale durante la gestione del flusso di dati. La sua funzione è quella di far ``sprecare" un ciclo di clock al processore. Ciò ci assicura sia in caso di scrittura, sia in caso di lettura, che i segnali in ingresso e in uscita siano letti o scritti correttamente. Nello specifico, questo stato evita che lo stato successivo lavori con dati relativi allo stato precedente. In base allo stato chiamante instrada lo stato prossimo in modo opportuno.\\

\textbf{N.B:} \textit{Alcune chiamate a questo stato potevano essere evitate. Questa informazione è emersa durante lo stress test a cui il processore è stato sottoposto. Tuttavia, è stato scelto di forzare ugualmente l’attesa per ovviare eventuali errori e per permettere la corretta acquisizione dei dati indipendentemente dal periodo di clock scelto. Ciò dovrebbe permettere una maggior robustezza, sebbene un aumento nella latenza della computazione.}

\subsubsection{GET\_RC}
\texttt{GET\_RC} si occupa della lettura dei primi due pixel della memoria in cui sono contenute le dimensioni dell’immagine da modificare. Viene invocato dopo l'abilitazione della memoria alla lettura e aggiorna i segnali \texttt{n\_col} e \texttt{n\_row}. Lo stato richiama se stesso fino a quando non ha aggiornato i due segnali, altrimenti imposta lo stato prossimo a \texttt{GET\_DIM}.

\subsubsection{GET\_DIM}
Lo stato \texttt{GET\_DIM} si preoccupa di aggiornare il segnale \texttt{dim\_address} con l'indirizzo del primo bit libero per la scrittura. Il calcolo che ne determina il valore è: $n\_col \cdot n\_row + 2$.\\
\texttt{GET\_DIM} verifica inoltre il caso speciale in cui una delle dimensioni dovesse essere nulla. In quel caso impone lo stato prossimo a \texttt{DONE}.\\

\textbf{N.B:}\textit{
La moltiplicazione usa segnali \textit{std\_logic\_vector} da $8$ bit e produce un risultato su $16$ bit. Essendo \texttt{dim\_address} un \textit{std\_logic\_vector} su $16$ bit, il problema non si pone.
}

\subsubsection{READ\_PIXEL}
\texttt{READ\_PIXEL} è uno stato strettamente connesso con lo stato \texttt{GET\_MINMAX}. Richiede alla memoria il valore del pixel da leggere e aggiorna il segnale \texttt{curr\_address} a quello successivo. In questo modo il valore del pixel sarà disponibile sul segnale \texttt{i\_data} dopo due \textit{rising\_edge} successivi. L'attesa è sempre lasciata allo stato \texttt{WAIT\_MEM}

\subsubsection{GET\_MINMAX}
\texttt{GET\_MINMAX} aggiorna i segnali \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value}, inizializzati rispettivamente con $0$ e $255$, con il valore di \texttt{i\_data}. Questo avviene se e solo se si verifica che \texttt{i\_data} è \textit{maggiore} di \texttt{max\_pixel\_value} (in questo caso aggiorna \texttt{max\_pixel\_value}) oppure se \texttt{i\_data} è \textit{minore} di \texttt{min\_pixel\_value} (in questo caso aggiorna \texttt{min\_pixel\_value}). Imposta lo stato prossimo a \texttt{READ\_PIXEL}
%non so perche lo mette in viola

\subsubsection{GET\_DELTA}
\texttt{GET\_DELTA} è uno stato banale. Calcola la \textit{differenza} tra \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} e imposta lo stato prossimo a \texttt{WAIT\_MEM}.

\pagebreak

\subsubsection{CALC\_SHIFT}
Lo stato \texttt{CALC\_SHIFT} si preoccupa di effettuare la riga $2$ dello speudo-codice riportato al paragrafo $1.2$.
Per effettuare il calcolo, richiama se stesso (attraverso lo stato \texttt{WAIT\_MEM}) aggiornando dei segnali d'appoggio. Nel dettaglio si potrebbe semplificare il tutto con il seguente pseudo-codice:
\\
\\
\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
\begin{algorithmic}[1]
  \State $m \gets delta\_value+1$
  \State $k \gets -1$
  \State $t \gets 1$
   \While{$t\leq m$}
   \State $k \gets k+1$
       \State $t \gets t*2$
  \EndWhile
  \State $shift\_level \gets 8-k$
\end{algorithmic}
\end{varwidth}
}
\\
\\
\\
Sostanzialmente attraverso il ciclo \texttt{WHILE} si ricava \textit{k}, il quale non è altro che il valore di $\floor{log_2(delta\_value +1)}$. Questa procedura è forse quella più dispendiosa a livello di tempo e memoria, poichè per aggiornare ogni segnale si deve come minimo attendere due cicli di clock. Inoltre, la moltiplicazione tra due interi (\textit{t} e $2$) produce un risultato su $64$ \textit{bit} che VHDL gestisce troncando a $32$ \textit{bit}. Per le specifiche del progetto ci si aspetta che \textit{k} non possa assumere un valore maggiore di $8$, pertando si è certi che una variabile a $32$ \textit{bit} possa largamente contenere i valori desiderati.

\subsubsection{GET\_PIXEL}
\texttt{GET\_PIXEL} è uno stato omonimo di \texttt{READ\_PIXEL}. La principale differenza del primo con il secondo è che mentre \texttt{READ\_PIXEL} effettua dei controlli sul flusso della computazione, \texttt{GET\_PIXEL} richiede solamente alla memoria il dato da leggere e imposta lo stato prossimo a \texttt{WAIT\_MEM}.

\subsubsection{CALC\_NEWPIXEL}
In \texttt{CALC\_NEWPIXEL} si calcola il nuovo valore del pixel da scrive in memoria.
Per farlo, viene utilizzata una variabile di appoggio \texttt{pixel\_to\_shift} definita come uno \textit{std\_logic\_vector} da $16$ \textit{bit} e inizializzata come $\texttt{i\_data}-\texttt{min\_pixel\_value}$ con l’aggiunta di otto `$0$' in posizione più significativa.
La variabile viene, quindi, shiftata e su di essa viene fatto il seguente controllo: se risulta essere minore di $255$ allora aggiorniamo il segnale \texttt{new\_pixel} al suo valore in \textit{std\_logic\_vector} su $8$\textit{bit}, altrimenti il segnale \texttt{new\_pixel} viene impostato a $255$ sempre in \textit{std\_logic\_vector} su $8$ \textit{bit}.

\subsubsection{WRITE\_PIXEL}
Lo stato \texttt{WRITE\_PIXEL} si assicura che il valore del nuovo pixel calcolato sia scritto in memoria, incrementa tutti i contatori e controlla di non essere arrivato al termine della computazione. Il controllo usufruisce della varibile intera \texttt{last}, che assume il valore di $2*\texttt{n\_col}*\texttt{n\_row}+2$, ovvero l'indice dell'ultimo pixel scrivibile. Quando il contatore assume questo valore lo stato successivo viene impostato a \texttt{DONE} (sempre attravero \texttt{WAIT\_MEM}), altrimenti viene impostato lo stato prossimo a \texttt{ABILIT\_READ}, dove la scrittura viene disabilitata e viene riabilitata la lettura per il pixel successivo.

\subsubsection{DONE}
\texttt{DONE} chiude tutte le comunicazioni con la memoria, riportando a `$0$' sia \texttt{o\_en} che \texttt{o\_we} e pulendo il buffer di \texttt{o\_address} e \texttt{o\_data}.
Successivamente il segnale \texttt{o\_done} viene portato ad `$1$' e lo stato prossimo è impostato a \texttt{ WAITING\_PIC}.


\subsubsection{WAITINGPIC}
Ultimo stato del processo. Ha lo scopo di restare in attesa che il segnale di \texttt{o\_done} venga riportato a `$0$'. Finche ciò non avviene, \texttt{ WAITING\_PIC} richiama se stesso. Quando sia \texttt{i\_start} che \texttt{o\_done} hanno il segnale a `$0$', imposta lo stato prossimo a \texttt{START} facendo ricominciare l’intera compilazione.

\pagebreak

\subsection{Schema process STATES}
%FSA
\vspace{0.5 cm}
\begin{center}
\resizebox{!}{24cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
        scale = 1,transform shape, on grid]

  \node[state] (start) [scale=1] {$START$};
  \node[state] (init) [below=of start, scale=1]  {$INIT$};
  \node[state] (abilitread) [below= of init, scale=0.5]  {$ABILIT\_READ$};
  \node[state] (getrc) [below=of abilitread, scale=0.8, yshift=-0.5cm]  {$GET\_RC$};
  \node[state] (getdim) [below=of getrc, scale=0.6]  {$GET\_DIM$};
  \node[state] (readpixel) [below=of getdim, scale=0.5]  {$READ\_PIXEL$};
  \node[state] (getminmax) [below =of readpixel, scale=0.5] {$GET\_MINMAX$};
  \node[state] (getdelta) [below =of getminmax, scale=0.5] {$GET\_DELTA$};
  \node[state] (calcshift) [below=of getdelta, scale=0.5]  {$CALC\_SHIFT$};
  \node[state] (getpixel) [below=of calcshift, scale=0.5 ]  {$GET\_PIXEL$};
  \node[state] (calcnewpixel) [below=of getpixel, scale=0.5]  {$CALC\_NEWPIXEL$};
  \node[state] (abilitwrite) [below=of calcnewpixel, scale=0.5, yshift=-1cm]  {$ABILIT\_WRITE$};
  \node[state] (writepixel) [below=of abilitwrite, scale=0.5, yshift=-1cm]  {$WRITE\_PIXEL$};
  \node[state] (done) [below=of writepixel, scale=0.7]  {$DONE$};
  \node[state] (waitingpic) [below=of done, scale=0.6]  {$WAITINGPIC$};
  \node[state] (waitmem) [right=of calcshift, xshift=8cm, scale=1.2]  {$WAIT\_MEM$};

  \draw (start) edge node{} (init)
        (init) edge node{} (abilitread)
        (abilitread) edge node{} (getrc)
        (getrc) edge[bend left, out=60, in=45, looseness=1] node{} (waitmem)
        (waitmem) edge[bend right, in=-100, out=200, looseness=2] node{} (getrc)
        (getdim) edge[bend left, in=120] node{} (waitmem)
        (waitmem) edge[bend right, out=-70, in=-100] node{} (getdim)
        (readpixel) edge[bend left, out=50, in=130] node{} (waitmem)
        (waitmem) edge[bend right, out=-30] node{} (getminmax)
        (getminmax) edge node{} (readpixel)
        (readpixel) edge[bend right=90] node{} (getdelta)
        (waitmem) edge [bend right, out=-30] node{} (readpixel)
        (getdelta) edge[bend left] node{} (waitmem)
        (waitmem) edge[bend right=20] node{} (calcshift)
        (calcshift) edge[bend right=20] node{} (waitmem)
        (calcshift) edge node{} (getpixel)
        (getpixel) edge[bend right] node{} (waitmem)
        (waitmem) edge[bend left, out=70] node{} (calcnewpixel)
        (calcnewpixel) edge node{} (abilitwrite)
        (abilitwrite) edge node{} (writepixel)
        (writepixel) edge[bend right, in=-80] node{} (waitmem)
        (writepixel) edge[bend left, in=140] node{} (abilitread)
        (abilitread) edge[bend right] node{} (getpixel)
        (waitmem) edge[bend left, out=100, looseness=2] node{} (done)
        (done) edge node{} (waitingpic)
        (waitingpic) edge[bend left] node{} (start)
        ;
\end{tikzpicture}
}
\end{center}

\pagebreak


\section{Risultati dei Test}
Write somenthing here!

\section{Conclusioni}
Write somenthing here

\end{document}
