\documentclass[11pt, a4paper]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[italian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[colorlinks=true, allcolors=black]{hyperref}
\usepackage{makeidx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{varwidth}
\usetikzlibrary{automata, positioning, decorations.text, topaths, arrows.meta, decorations.pathmorphing, quotes, shapes.geometric, arrows}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\tikzset{
->, % makes the edges directed
%>=stealth’, % makes the arrow heads bold
node distance=1cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

%for code
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=VHDL,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  backgroundcolor=\color{white}
}

\title{Progetto di Reti Logiche}
\author{
  William Zeni\\
  \texttt{matricola 10613915}
  \and
  Cristina Urso\\
  \texttt{matricola 10599689}
}

\date{Anno 2020/21}

\graphicspath{ {./graphics/} }

\makeindex

\begin{document}

\begin{figure}[t]
  \centering
  \vspace{3cm}
  \includegraphics[scale=0.4]{Logo_Politecnico_Milano.png}
  \vspace{3cm}
\end{figure}

\maketitle
\renewcommand{\abstractname}{ }
\begin{abstract}
  \centering
  Progetto sostenuto presso il Politecnico di Milano - Dipartimento di Elettronica, Informazione e Bioingegneria. Corso diretto dal Prof. Gianluca Palermo.
\end{abstract}

\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}
\pagebreak
\pagenumbering{arabic}


\section{Introduzione}
\subsection{Scopo del progetto}
Lo scopo del progetto è quello di creare un componente hardware sintetizzabile, in grado di equalizzare un immagine. L'algoritmo che ne prevede l'equalizzazione si ispira ad una versione semplificata del metodo di equalizzazione dell'istogramma, il quale prevede un aumento nel contrasto di un immagine su scala di grigi. In generale l'elaborazione digitale dell'immagine risulta più evidente specialmente quando i dati raccolti sono rappresentati da valori di intensità molto vicini. Per cui, se una immagine contenesse una scala di grigi molto ampia, l'effeto dell'equalizzazione risulterebbe pressochè nullo.

\subsection{Specifiche generali}
Si definisca un immagine dalle dimensioni variabili, ma di massimo $128 \times 128$, e si definisca una memoria lineare nella quale i primi due valori siano le dimensioni dell'immagine e i restanti i valori assegnati ad ogni pixel, il componente hardware dovrà scrivere in coda alla memoria l'immagine equalizzata pixel per pixel.
Il risultato sarà una memoria complessivamente lunga $2 \cdot N_{col} \cdot N_{row} +2$, dove $N_{row}$ e $N_{col}$ sono rispettivamente il numero di righe e di colonne dell'immagine. A partire dalla posizione 2, per ogni pixel si avrà il corrispettivo pixel equalizzato ad una distanza $N_{col} \cdot N_{row}$ come mostrato in figura.
\\
\\

\begin{tikzpicture}
\draw[step=1cm, black,very thin] (0,0) grid (13,1);
\fill[text=black] (0.5,0.5) node{$N_{col}$};
\fill[text=black] (0.5,1.3) node{$0$};
\fill[text=black] (1.5,0.5) node{$N_{row}$};
\fill[text=black] (1.5,1.3) node{$1$};
\fill[blue!30!white, draw=black] (2,0) rectangle (3,1);
\fill[text=black] (2.5,1.3) node{$2$};
\fill[green!30!white, draw=black] (3,0) rectangle (4,1);
\fill[text=black] (3.5,1.3) node{$3$};
\fill[red!30!white, draw=black] (4,0) rectangle (5,1);
\fill[text=black] (4.5,1.3) node{$4$};
\fill[text=black] (5.5,0.5) node{\dots};
\fill[text=black] (6.5,0.5) node{\dots};
\fill[text=black] (7.5,0.5) node{\dots};
\fill[blue!30!white, draw=black] (8,0) rectangle (9,1);
\fill[text=black] (8.5,1.3) node{$N_{col}\cdot N_{row}+2$};
\fill[text=black] (8.5,-0.5) node{\texttt{new\_pixel}};
\fill[green!30!white, draw=black] (9,0) rectangle (10,1);
\fill[red!30!white, draw=black] (10,0) rectangle (11,1);
\fill[text=black] (11.5,0.5) node{\dots};
\end{tikzpicture}
\\
La memoria dialogherà in stretto contatto con il componente attraverso due segnali, che determineranno l'avvio della computazione, la sua terminazione e l'eventuale ripartenza. Si noti che la computazione di una singola immagine, una volta iniziata, non potrà mai essere interrotta, ma rimane possibile la computazione di più immagini.\\
\\
Ogni pixel avrà un valore compreso tra $0$ e $255$ e verrà rielaborato dal componente nel seguente modo:\\
\\

\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

\begin{algorithmic}[1]
  \State $delta\_value \gets max\_pixel\_value - min\_pixel\_value$
  \State $shift\_level \gets 8 - \floor{\log_2(delta\_value+1)}$
  \State $temp\_pixel \gets curr\_pixel\_value - min\_pixel\_value$
  \State $temp\_pixel \gets temp\_pixel << shift\_level$
  \If{$temp\_pixel > 255$}
    \State $new\_pixel \gets 255$
  \Else
    \State $new\_pixel \gets temp\_pixel$
  \EndIf
\end{algorithmic}

\end{varwidth}
}
\\
\\
\\
dove \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} sono rispettivamente il valore massimo e il valore minimo del pixel trovati all'interno dell'immagine, \texttt{curr\_pixel\_value} è il valore del pixel preso in considerazione e \texttt{new\_pixel} è il valore del pixel da scrivere in memoria.
\pagebreak

\subsection{Interfaccia del componente}
\begin{lstlisting}
entity project_reti_logiche is
port (
    i_clk       : in std_logic;
    i_rst       : in std_logic;
    i_start     : in std_logic;
    i_data      : in std_logic_vector(7 downto 0);
    o_address   : out std_logic_vector(15 downto 0);
    o_done      : out std_logic;
    o_en        : out std_logic;
    o_we        : out std_logic;
    o_data      : out std_logic_vector (7 downto 0)
);
end project_reti_logiche;
\end{lstlisting}
L'interfaccia del componente, per potersi relazionare con la memoria, deve essere come quella sopra riportata. I segnali di input vengono evidenziati dal prefisso \texttt{\lq i\_'}, mentre per i segnali di output è presente il prefisso \texttt{\lq o\_'}. Nel dettaglio:
\begin{itemize}
  \item \textbf{i\_clk} scandisce il ciclo di clock della memoria, registrando \lq$1$' sul \texttt{rising\_edge}.
  \item \textbf{i\_rst} è il segnale di \texttt{RESET}, viene chiamato all'inizio della computazione di una o più immagini. Se si registra \lq$1$' su questo segnale la computazione deve essere terminata e ripristinata al momento di partenza.
  \item \textbf{i\_start} determina l'inizio della coputazione. Questo segnale rimane alto fino a quando la computazione non termina. La computazione può iniziare solo se il segnale è basso.
  \item \textbf{i\_data} raccoglie i dati inviati dalla memoria.
  \item \textbf{o\_address} è il segnale attraverso il quale facciamo richieste alla memoria. Sostanzialmente su questo segnale si pone l'indirizzo della memoria che si vuuole leggere o sulla quale si vuole scrivere.
  \item \textbf{o\_done} determina la fine della computazione. Il segnale deve essere portato alto quando si vuole terminare la computazione e deve rimanere alto fino a quando la memoria non porti il segnale di \texttt{START} basso. Solo in quel caso il segnale viene riportato basso.
  \item \textbf{o\_en} abilita la memoria alla lettura o alla scrittura.
  \item \textbf{o\_we}  abilita la memoria alla scrittura. Quando questo segnale è alto la memoria si aspetta un dato in ingresso da scrivere.
  \item \textbf{o\_data} è il dato che la memoria si aspetta di leggere quando la scrittura è attiva.
\end{itemize}
\pagebreak
\subsection{Dati e Descrizione memoria}
Write somenthing here

\pagebreak
\section{Desing Pattern}
\subsection{Scelte Progettuali}
La struttura del progetto è stata suddivisa in due process principali: \texttt{UPDATE} e \texttt{STATES}.
Il primo ha il compito di relazionarsi con la memoria e il secondo contiene gli stati della macchina impiegati nella equalizzazione delle immagini. In questo modo una porzione di codice è adibita esclusivamente alla computazione dei pixel (process \texttt{STATES}), mentre la rimanente si occupa dei segnali di output della \textit{entity} (process \texttt{UPDATE}).\\
Per permette un corretto dialogo tra i due process è nata l'esigenza di avere dei segnali ``duplicati".
I segnali con suffisso \texttt{\lq\_cp'} sono stati introdotti per mantere in memoria i valori computati, mentre i segnali con suffisso \texttt{\lq\_next'} sono stati implementati allo scopo di permettere agli stati di far richieste alla memoria.
Nel particolare, per ogni ciclo di clock, durante il \textit{rising\_edge}, il process \texttt{UPDATE} si risveglia, aggiornando i segnali. I segnali contenenti i valori da mantenere vengono reimpostati con i segnali \texttt{\lq\_cp'}, mentre i segnali di output della \textit{entity} sono aggiornati con i segnali \texttt{\lq\_next'}.

Il succo della computazione è trattunuto dal process \texttt{STATES}, che è a tutti gli effetti un \texttt{FSA} (\textit{Macchina a Stati Finiti}) rappresentabile attraverso lo schema al paragrafo $2.3$.

\subsection{Elenco Stati}

\subsubsection{START}
Lo stato di \texttt{START} è il primo stato del process \texttt{STATES} ed è stato pensato come stato di attesa iniziale. Questo stato viene invocato in due situazioni differenti: se il segnale di \texttt{i\_rst} viene portato alto, oppure quando il segnale \texttt{i\_start} viene riportato basso dopo la computazione di un immagine. Lo stato \texttt{START} non cambia fino a quando il segnale \texttt{i\_start} non viene portato alto. In quel momento lo stato successivo viene impostato \texttt{INIT}.

\subsubsection{INIT}
\texttt{INIT} è uno stato di transizione nel quale il processore si assicura che i segnali siano inizializzati con i valori opportuni. Successivamente imposta lo stato prossimo a \texttt{ABILIT\_READ}.

\subsubsection{ABILIT\_READ}
Attraverso \texttt{ABILIT\_READ} si abilita la memoria alla sola lettura. Viene richiamato in due momenti diversi del progetto: all'inizio della computazione, subito dopo \texttt{INIT}, per portare il segnale \texttt{o\_en} a $1$ e permettere agli altri stati di poter leggere dalla memoria, oppure dopo la scrittura di un pixel, al fine di disabilitare l'accesso alla scrittura. In base allo stato chiamante, instrada lo stato prossimo a quello opportuno.

\subsubsection{ABILIT\_WRITE}
Lo stato \texttt{ABILIT\_WRITE} abilita la memoria alla scrittura. Viene invocato subito dopo aver computato il valore del nuovo pixel e in nessun altro momento. Instrada poi lo stato prossimo a \texttt{WRITE\_PIXEL}.

\pagebreak
\subsubsection{WAIT\_MEM}
\texttt{WAIT\_MEM} è uno stato centrale durante la gestione del flusso di dati. La sua funzione è quella di far ``sprecare" un ciclo di clock al processore. Ciò ci assicura sia in caso di scrittura, sia in caso di lettura, che i segnali in ingresso e in uscita siano letti o scritti correttamente. Nello specifico, questo stato evita che lo stato successivo lavori con dati relativi allo stato precedente.\\

\textbf{N.B:} \textit{Alcune chiamate a questo stato potevano essere evitate. Questa informazione è emersa durante lo stress test a cui il processore è stato sottoposto. Tuttavia, è stato scelto di forzare ugualmente l’attesa per ovviare eventuali errori e per permettere la corretta acquisizione dei dati indipendentemente dal periodo di clock scelto. Ciò dovrebbe permettere una maggior robustezza, sebbene un aumento nella latenza della computazione.}

\subsubsection{GET\_RC}
\texttt{GET\_RC} si occupa della lettura dei primi due pixel della memoria in cui sono contenute le dimensioni dell’immagine da modificare. Viene invocato dopo l'abilitazione della memoria alla lettura e aggiorna i segnali \texttt{n\_col} e \texttt{n\_row}. Lo stato richiama se stesso fino a quando non ha aggiornato i due segnali, altrimenti imposta lo stato prossimo a \texttt{GET\_DIM}.

\subsubsection{GET\_DIM}
Lo stato \texttt{GET\_DIM} si preoccupa di aggiornare il segnale \texttt{dim\_address} con l'indirizzo del primo bit libero per la scrittura. Il calcolo che ne determina il valore è: $n\_col \cdot n\_row + 2$.\\

\textbf{N.B:}\textit{
Se si usasse segnali \textit{std\_logic\_vector} da $8$ bit, la moltiplicazione produrrebbe un risultato su $16$ bit, che dovrebbe poi essere riportato a $8$ bit per il proseguimento della computazione. Pertanto, si lascia al linguaggio VHDL gestire il tutto usando segnali di tipo intero (\texttt{n\_col}, \texttt{n\_row} e \texttt{dim\_address}).
}

\subsubsection{READ\_PIXEL}
\texttt{READ\_PIXEL} è uno stato strettamente connesso con lo stato \texttt{GET\_MINMAX}. Richiede alla memoria il valore del pixel da leggere e aggiorna il segnale \texttt{curr\_address} a quello successivo. In questo modo il valore del pixel sarà disponibile sul segnale \texttt{i\_data} al \textit{rising\_edge} successivo.

\subsubsection{GET\_MINMAX}
Write somenthing here.

\subsubsection{GET\_DELTA}
Write somenthing here

\subsubsection{CALC\_SHIFT}
Write somenthing here

\subsubsection{GET\_PIXEL}
Write somenthing here

\subsubsection{CALC\_NEWPIXEL}
Write somenthing here

\subsubsection{WRITE\_PIXEL}
Write somenthing here.

\subsubsection{DONE}
Write somenthing here

\subsubsection{WAITINGPIC}
Write somenthing here

\pagebreak

\subsection{Schema process STATES}
%FSA
\vspace{0.5 cm}
\begin{center}
\resizebox{!}{24cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
        scale = 1,transform shape, on grid]

  \node[state] (start) [scale=1] {$START$};
  \node[state] (init) [below=of start, scale=1]  {$INIT$};
  \node[state] (abilitread) [below= of init, scale=0.5]  {$ABILIT\_READ$};
  \node[state] (getrc) [below=of abilitread, scale=0.8, yshift=-0.5cm]  {$GET\_RC$};
  \node[state] (getdim) [below=of getrc, scale=0.6]  {$GET\_DIM$};
  \node[state] (readpixel) [below=of getdim, scale=0.5]  {$READ\_PIXEL$};
  \node[state] (getminmax) [below =of readpixel, scale=0.5] {$GET\_MINMAX$};
  \node[state] (getdelta) [below =of getminmax, scale=0.5] {$GET\_DELTA$};
  \node[state] (calcshift) [below=of getdelta, scale=0.5]  {$CALC\_SHIFT$};
  \node[state] (getpixel) [below=of calcshift, scale=0.5 ]  {$GET\_PIXEL$};
  \node[state] (calcnewpixel) [below=of getpixel, scale=0.5]  {$CALC\_NEWPIXEL$};
  \node[state] (abilitwrite) [below=of calcnewpixel, scale=0.5, yshift=-1cm]  {$ABILIT\_WRITE$};
  \node[state] (writepixel) [below=of abilitwrite, scale=0.5, yshift=-1cm]  {$WRITE\_PIXEL$};
  \node[state] (done) [below=of writepixel, scale=0.7]  {$DONE$};
  \node[state] (waitingpic) [below=of done, scale=0.6]  {$WAITINGPIC$};
  \node[state] (waitmem) [right=of calcshift, xshift=8cm, scale=1.2]  {$WAIT\_MEM$};

  \draw (start) edge node{} (init)
        (init) edge node{} (abilitread)
        (abilitread) edge node{} (getrc)
        (getrc) edge[bend left, out=60, in=45, looseness=1] node{} (waitmem)
        (waitmem) edge[bend right, in=-100, out=200, looseness=2] node{} (getrc)
        (getdim) edge[bend left, in=120] node{} (waitmem)
        (waitmem) edge[bend right, out=-70, in=-100] node{} (getdim)
        (readpixel) edge[bend left, out=50, in=130] node{} (waitmem)
        (waitmem) edge[bend right, out=-30] node{} (getminmax)
        (getminmax) edge node{} (readpixel)
        (readpixel) edge[bend right=90] node{} (getdelta)
        (waitmem) edge [bend right, out=-30] node{} (readpixel)
        (getdelta) edge[bend left] node{} (waitmem)
        (waitmem) edge[bend right=20] node{} (calcshift)
        (calcshift) edge[bend right=20] node{} (waitmem)
        (calcshift) edge node{} (getpixel)
        (getpixel) edge[bend right] node{} (waitmem)
        (waitmem) edge[bend left, out=70] node{} (calcnewpixel)
        (calcnewpixel) edge node{} (abilitwrite)
        (abilitwrite) edge node{} (writepixel)
        (writepixel) edge[bend right, in=-80] node{} (waitmem)
        (writepixel) edge[bend left] node{} (abilitread)
        (waitmem) edge[bend left, out=100, looseness=2] node{} (done)
        (done) edge node{} (waitingpic)
        (waitingpic) edge[bend left, above] node{} (start)
        ;
\end{tikzpicture}
}
\end{center}

\pagebreak


\section{Risultati dei Test}
Write somenthing here!

\section{Conclusioni}
Write somenthing here

\end{document}
