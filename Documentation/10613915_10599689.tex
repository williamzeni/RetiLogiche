\documentclass[11pt, a4paper]{article}

% Language setting
% Replace `english' with e.g. `spanish' to change the document language
\usepackage[italian]{babel}

% Set page size and margins
% Replace `letterpaper' with`a4paper' for UK/EU standard size
\usepackage[a4paper,top=2cm,bottom=2cm,left=3cm,right=3cm,marginparwidth=1.75cm]{geometry}

% Useful packages
\usepackage{float}
\usepackage{amsmath}
%\usepackage{graphicx}
%\usepackage[colorlinks=true, allcolors=black]{hyperref}
%\usepackage{makeidx}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{mathtools}
\usepackage{varwidth}

\DeclareRobustCommand{\willy}[1]{
\definecolor{mycolor#1}{RGB}{#1,#1,#1}
}
\willy{0}
\willy{1}
\willy{2}
\willy{3}
\willy{4}
\willy{5}
\willy{6}
\willy{7}
\willy{8}
\willy{9}
\willy{10}
\willy{11}
\willy{12}
\willy{13}
\willy{14}
\willy{15}
\willy{16}
\willy{17}
\willy{18}
\willy{19}
\willy{20}
\willy{21}
\willy{22}
\willy{23}
\willy{24}
\willy{25}
\willy{26}
\willy{27}
\willy{28}
\willy{29}
\willy{30}
\willy{31}
\willy{32}
\willy{33}
\willy{34}
\willy{35}
\willy{36}
\willy{37}
\willy{38}
\willy{39}
\willy{40}
\willy{41}
\willy{42}
\willy{43}
\willy{44}
\willy{45}
\willy{46}
\willy{47}
\willy{48}
\willy{49}
\willy{50}
\willy{51}
\willy{52}
\willy{53}
\willy{54}
\willy{55}
\willy{56}
\willy{57}
\willy{58}
\willy{59}
\willy{60}
\willy{61}
\willy{62}
\willy{63}
\willy{64}
\willy{65}
\willy{66}
\willy{67}
\willy{68}
\willy{69}
\willy{70}
\willy{71}
\willy{72}
\willy{73}
\willy{74}
\willy{75}
\willy{76}
\willy{77}
\willy{78}
\willy{79}
\willy{80}
\willy{81}
\willy{82}
\willy{83}
\willy{84}
\willy{85}
\willy{86}
\willy{87}
\willy{88}
\willy{89}
\willy{90}
\willy{91}
\willy{92}
\willy{93}
\willy{94}
\willy{95}
\willy{96}
\willy{97}
\willy{98}
\willy{99}
\willy{100}
\willy{101}
\willy{102}
\willy{103}
\willy{104}
\willy{105}
\willy{106}
\willy{107}
\willy{108}
\willy{109}
\willy{110}
\willy{111}
\willy{112}
\willy{113}
\willy{114}
\willy{115}
\willy{116}
\willy{117}
\willy{118}
\willy{119}
\willy{120}
\willy{121}
\willy{122}
\willy{123}
\willy{124}
\willy{125}
\willy{126}
\willy{127}
\willy{128}
\willy{129}
\willy{130}
\willy{131}
\willy{132}
\willy{133}
\willy{134}
\willy{135}
\willy{136}
\willy{137}
\willy{138}
\willy{139}
\willy{140}
\willy{141}
\willy{142}
\willy{143}
\willy{144}
\willy{145}
\willy{146}
\willy{147}
\willy{148}
\willy{149}
\willy{150}
\willy{151}
\willy{152}
\willy{153}
\willy{154}
\willy{155}
\willy{156}
\willy{157}
\willy{158}
\willy{159}
\willy{160}
\willy{161}
\willy{162}
\willy{163}
\willy{164}
\willy{165}
\willy{166}
\willy{167}
\willy{168}
\willy{169}
\willy{170}
\willy{171}
\willy{172}
\willy{173}
\willy{174}
\willy{175}
\willy{176}
\willy{177}
\willy{178}
\willy{179}
\willy{180}
\willy{181}
\willy{182}
\willy{183}
\willy{184}
\willy{185}
\willy{186}
\willy{187}
\willy{188}
\willy{189}
\willy{190}
\willy{191}
\willy{192}
\willy{193}
\willy{194}
\willy{195}
\willy{196}
\willy{197}
\willy{198}
\willy{199}
\willy{200}
\willy{201}
\willy{202}
\willy{203}
\willy{204}
\willy{205}
\willy{206}
\willy{207}
\willy{208}
\willy{209}
\willy{210}
\willy{211}
\willy{212}
\willy{213}
\willy{214}
\willy{215}
\willy{216}
\willy{217}
\willy{218}
\willy{219}
\willy{220}
\willy{221}
\willy{222}
\willy{223}
\willy{224}
\willy{225}
\willy{226}
\willy{227}
\willy{228}
\willy{229}
\willy{230}
\willy{231}
\willy{232}
\willy{233}
\willy{234}
\willy{235}
\willy{236}
\willy{237}
\willy{238}
\willy{239}
\willy{240}
\willy{241}
\willy{242}
\willy{243}
\willy{244}
\willy{245}
\willy{246}
\willy{247}
\willy{248}
\willy{249}
\willy{250}
\willy{251}
\willy{252}
\willy{253}
\willy{254}
\willy{255}

\usetikzlibrary{automata, positioning, decorations.text, topaths, arrows.meta, decorations.pathmorphing, quotes, shapes.geometric, arrows}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

\tikzset{
->, % makes the edges directed
%>=stealth’, % makes the arrow heads bold
node distance=1cm, % specifies the minimum distance between two nodes. Change if necessary.
every state/.style={thick, fill=gray!10}, % sets the properties for each ’state’ node
initial text=$ $, % sets the text that appears on the start arrow
}

%for code
\usepackage{listings}

\makeatletter
\long\def\@makecaption#1#2{%
  \vskip\abovecaptionskip
    \bfseries #1: #2\par
  \vskip\belowcaptionskip}%
\makeatother

%\usepackage{color}

%\definecolor{dkgreen}{rgb}{0,0.6,0}
%\definecolor{gray}{rgb}{0.5,0.5,0.5}
%\definecolor{mauve}{rgb}{0.58,0,0.82}


\lstset{frame=tb,
  language=VHDL,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=left,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  backgroundcolor=\color{white}
}

\title{Progetto di Reti Logiche}
\author{
  William Zeni\\
  \texttt{matricola 10613915}
  \and
  Cristina Urso\\
  \texttt{matricola 10599689}
}

\date{Anno 2020/21}

\graphicspath{ {./graphics/} }

\makeindex

\begin{document}

\begin{figure}[t]
  \centering
  \vspace{3cm}
  \includegraphics[scale=0.4]{Logo_Politecnico_Milano.png}
  \vspace{3cm}
\end{figure}

\maketitle
\renewcommand{\abstractname}{ }
\begin{abstract}
  \centering
  Progetto sostenuto presso il Politecnico di Milano - Dipartimento di Elettronica, Informazione e Bioingegneria. Corso diretto dal Prof. Gianluca Palermo.
\end{abstract}

\thispagestyle{empty}
\pagebreak
\tableofcontents
\thispagestyle{empty}
\pagebreak
\pagenumbering{arabic}


\section{Introduzione}
\subsection{Scopo del progetto}
Lo scopo del progetto è quello di creare un componente hardware sintetizzabile, in grado di equalizzare un immagine. L'algoritmo che ne prevede l'equalizzazione si ispira ad una versione semplificata del metodo di equalizzazione dell'istogramma, il quale prevede un aumento nel contrasto di un immagine su scala di grigi. In generale l'elaborazione digitale dell'immagine risulta più evidente specialmente quando i dati raccolti sono rappresentati da valori di intensità molto vicini. Per cui, se una immagine contenesse una scala di grigi molto ampia, l'effeto dell'equalizzazione risulterebbe pressochè nullo.

\subsection{Specifiche generali}
Si definisca un immagine dalle dimensioni variabili, ma di massimo $128 \times 128$, e si definisca una memoria lineare nella quale i primi due valori siano le dimensioni dell'immagine e i restanti i valori assegnati ad ogni pixel, il componente hardware dovrà scrivere in coda alla memoria l'immagine equalizzata pixel per pixel.
Il risultato sarà una memoria complessivamente lunga $2 \cdot N_{col} \cdot N_{row} +2$, dove $N_{row}$ e $N_{col}$ sono rispettivamente il numero di righe e di colonne dell'immagine. A partire dalla posizione 2, per ogni pixel si avrà il corrispettivo pixel equalizzato ad una distanza $N_{col} \cdot N_{row}$ come mostrato in figura.
\\
\\

\begin{tikzpicture}
\draw[step=1cm, black,very thin] (0,0) grid (13,1);
\fill[text=black] (0.5,0.5) node{$N_{col}$};
\fill[text=black] (0.5,1.3) node{$0$};
\fill[text=black] (1.5,0.5) node{$N_{row}$};
\fill[text=black] (1.5,1.3) node{$1$};
\fill[blue!30!white, draw=black] (2,0) rectangle (3,1);
\fill[text=black] (2.5,1.3) node{$2$};
\fill[green!30!white, draw=black] (3,0) rectangle (4,1);
\fill[text=black] (3.5,1.3) node{$3$};
\fill[red!30!white, draw=black] (4,0) rectangle (5,1);
\fill[text=black] (4.5,1.3) node{$4$};
\fill[text=black] (5.5,0.5) node{\dots};
\fill[text=black] (6.5,0.5) node{\dots};
\fill[text=black] (7.5,0.5) node{\dots};
\fill[blue!30!white, draw=black] (8,0) rectangle (9,1);
\fill[text=black] (8.5,1.3) node{$N_{col}\cdot N_{row}+2$};
\fill[text=black] (8.5,-0.5) node{\texttt{new\_pixel}};
\fill[green!30!white, draw=black] (9,0) rectangle (10,1);
\fill[red!30!white, draw=black] (10,0) rectangle (11,1);
\fill[text=black] (11.5,0.5) node{\dots};
\end{tikzpicture}
\\
La memoria dialogherà in stretto contatto con il componente attraverso due segnali, che determineranno l'avvio della computazione, la sua terminazione e l'eventuale ripartenza. Si noti che la computazione di una singola immagine, una volta iniziata, non potrà mai essere interrotta, ma rimane possibile la computazione di più immagini.\\
\\
Ogni pixel avrà un valore compreso tra $0$ e $255$ e verrà rielaborato dal componente nel seguente modo:\\
\\

\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}

\begin{algorithmic}[1]
  \State $delta\_value \gets max\_pixel\_value - min\_pixel\_value$
  \State $shift\_level \gets 8 - \floor{\log_2(delta\_value+1)}$
  \State $temp\_pixel \gets curr\_pixel\_value - min\_pixel\_value$
  \State $temp\_pixel \gets temp\_pixel << shift\_level$
  \If{$temp\_pixel > 255$}
    \State $new\_pixel \gets 255$
  \Else
    \State $new\_pixel \gets temp\_pixel$
  \EndIf
\end{algorithmic}

\end{varwidth}
}
\\
\\
\\
dove \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} sono rispettivamente il valore massimo e il valore minimo del pixel trovati all'interno dell'immagine, \texttt{curr\_pixel\_value} è il valore del pixel preso in considerazione e \texttt{new\_pixel} è il valore del pixel da scrivere in memoria.
\pagebreak

\subsection{Interfaccia del componente}
\begin{lstlisting}
entity project_reti_logiche is
port (
    i_clk       : in std_logic;
    i_rst       : in std_logic;
    i_start     : in std_logic;
    i_data      : in std_logic_vector(7 downto 0);
    o_address   : out std_logic_vector(15 downto 0);
    o_done      : out std_logic;
    o_en        : out std_logic;
    o_we        : out std_logic;
    o_data      : out std_logic_vector (7 downto 0)
);
end project_reti_logiche;
\end{lstlisting}

L'interfaccia del componente, per potersi relazionare con la memoria, deve essere come quella sopra riportata. I segnali di input vengono evidenziati dal prefisso \texttt{\lq i\_'}, mentre per i segnali di output è presente il prefisso \texttt{\lq o\_'}. Nel dettaglio:
\begin{itemize}
  \item \textbf{i\_clk} scandisce il ciclo di clock della memoria, registrando \lq$1$' sul \texttt{rising\_edge}.
  \item \textbf{i\_rst} è il segnale di \texttt{RESET}, viene chiamato all'inizio della computazione di una o più immagini. Se si registra \lq$1$' su questo segnale la computazione deve essere terminata e ripristinata al momento di partenza.
  \item \textbf{i\_start} determina l'inizio della coputazione. Questo segnale rimane alto fino a quando la computazione non termina. La computazione può iniziare solo se il segnale è basso.
  \item \textbf{i\_data} raccoglie i dati inviati dalla memoria.
  \item \textbf{o\_address} è il segnale attraverso il quale facciamo richieste alla memoria. Sostanzialmente su questo segnale si pone l'indirizzo della memoria che si vuuole leggere o sulla quale si vuole scrivere.
  \item \textbf{o\_done} determina la fine della computazione. Il segnale deve essere portato alto quando si vuole terminare la computazione e deve rimanere alto fino a quando la memoria non porti il segnale di \texttt{START} basso. Solo in quel caso il segnale viene riportato basso.
  \item \textbf{o\_en} abilita la memoria alla lettura o alla scrittura.
  \item \textbf{o\_we}  abilita la memoria alla scrittura. Quando questo segnale è alto la memoria si aspetta un dato in ingresso da scrivere.
  \item \textbf{o\_data} è il dato che la memoria si aspetta di leggere quando la scrittura è attiva.
\end{itemize}
\pagebreak
\subsection{Dati e Descrizione memoria}
\begin{lstlisting}[title={Fig.1}]
architecture projecttb of project_tb is
  constant    c_CLOCK_PERIOD     : time := 15 ns;
  signal      mem_address        : std_logic_vector (15 downto 0);
  signal      mem_o_data         : std_logic_vector (7 downto 0);
  signal      mem_i_data         : std_logic_vector (7 downto 0);
  signal      tb_done            : std_logic;
  signal      tb_rst             : std_logic;
  signal      tb_start           : std_logic;
  signal      tb_clk             : std_logic;
  signal      enable_wire        : std_logic;
  signal      mem_we             : std_logic;

type ram_type is array (65535 downto 0) of std_logic_vector(7 downto 0);
\end{lstlisting}
\begin{lstlisting}[title={Fig. 2}]
begin
UUT: project_reti_logiche
port map (
          i_clk       => tb_clk,
          i_start     => tb_start,
          i_rst       => tb_rst,
          i_data      => mem_o_data,
          o_address   => mem_address,
          o_done      => tb_done,
          o_en        => enable_wire,
          o_we        => mem_we,
          o_data      => mem_i_data
          );
\end{lstlisting}

\pagebreak
\section{Desing Pattern}
\subsection{Scelte Progettuali}
La struttura del progetto è stata suddivisa in due process principali: \texttt{UPDATE} e \texttt{STATES}.
Il primo ha il compito di relazionarsi con la memoria e il secondo contiene gli stati della macchina impiegati nella equalizzazione delle immagini. In questo modo una porzione di codice è adibita esclusivamente alla computazione dei pixel (process \texttt{STATES}), mentre la rimanente si occupa dei segnali di output della \textit{entity} (process \texttt{UPDATE}).\\
Per permette un corretto dialogo tra i due process è nata l'esigenza di avere dei segnali ``duplicati".
I segnali con suffisso \texttt{\lq\_cp'} sono stati introdotti per mantere in memoria i valori computati, mentre i segnali con suffisso \texttt{\lq\_next'} sono stati implementati allo scopo di permettere agli stati di far richieste alla memoria.
Nel particolare, per ogni ciclo di clock, durante il \textit{rising\_edge}, il process \texttt{UPDATE} si risveglia, aggiornando i segnali. I segnali contenenti i valori da mantenere vengono reimpostati con i segnali \texttt{\lq\_cp'}, mentre i segnali di output della \textit{entity} sono aggiornati con i segnali \texttt{\lq\_next'}.\\
Il process \texttt{STATES} è a tutti gli effetti un \texttt{FSA} (\textit{Macchina a Stati Finiti}) rappresentabile attraverso lo schema al paragrafo $2.3.1$.
Il suo funzionamento è permesso sostanzialmente da tre segnali a lui dedicati: \texttt{next\_state}, che identifica la chiamata allo stato prossimo,  \texttt{curr\_state}, che rileva lo stato corrente, e \texttt{prev\_state}, che conserva lo stato precedente.

\subsection{Elenco Stati - Process STATES}

\subsubsection{START}
Lo stato di \texttt{START} è il primo stato del process \texttt{STATES} ed è stato pensato come stato di attesa iniziale. Questo stato viene invocato in due situazioni differenti: se il segnale di \texttt{i\_rst} viene portato alto, oppure quando il segnale \texttt{i\_start} viene riportato basso dopo la computazione di un immagine. Lo stato \texttt{START} non cambia fino a quando il segnale \texttt{i\_start} non viene portato alto. In quel momento lo stato successivo viene impostato a \texttt{INIT}.

\subsubsection{INIT}
\texttt{INIT} è uno stato di transizione nel quale il processore si assicura che i segnali siano inizializzati con i valori opportuni. Successivamente imposta lo stato prossimo a \texttt{ABILIT\_READ}.

\subsubsection{ABILIT\_READ}
Attraverso \texttt{ABILIT\_READ} si abilita la memoria alla sola lettura. Viene richiamato in due momenti diversi del progetto: all'inizio della computazione, subito dopo \texttt{INIT}, per portare il segnale \texttt{o\_en} a $1$ e permettere agli altri stati di poter leggere dalla memoria, oppure dopo la scrittura di un pixel, al fine di disabilitare l'accesso alla scrittura. In base allo stato chiamante, instrada lo stato prossimo a quello opportuno.

\subsubsection{ABILIT\_WRITE}
Lo stato \texttt{ABILIT\_WRITE} abilita la memoria alla scrittura. Viene invocato subito dopo aver computato il valore del nuovo pixel e in nessun altro momento. Instrada poi lo stato prossimo a \texttt{WRITE\_PIXEL}.

\pagebreak
\subsubsection{WAIT\_MEM}
\texttt{WAIT\_MEM} è uno stato centrale durante la gestione del flusso di dati. La sua funzione è quella di far ``sprecare" un ciclo di clock al processore. Ciò ci assicura sia in caso di scrittura, sia in caso di lettura, che i segnali in ingresso e in uscita siano letti o scritti correttamente. Nello specifico, questo stato evita che lo stato successivo lavori con dati relativi allo stato precedente. In base allo stato chiamante instrada lo stato prossimo in modo opportuno.\\

\textbf{N.B:} \textit{Alcune chiamate a questo stato potevano essere evitate. Questa informazione è emersa durante lo stress test a cui il processore è stato sottoposto. Tuttavia, è stato scelto di forzare ugualmente l’attesa per ovviare eventuali errori e per permettere la corretta acquisizione dei dati indipendentemente dal periodo di clock scelto. Ciò dovrebbe permettere una maggior robustezza, sebbene un aumento nella latenza della computazione.}

\subsubsection{GET\_RC}
\texttt{GET\_RC} si occupa della lettura dei primi due pixel della memoria in cui sono contenute le dimensioni dell’immagine da modificare. Viene invocato dopo l'abilitazione della memoria alla lettura e aggiorna i segnali \texttt{n\_col} e \texttt{n\_row}. Lo stato richiama se stesso fino a quando non ha aggiornato i due segnali, altrimenti imposta lo stato prossimo a \texttt{GET\_DIM}.

\subsubsection{GET\_DIM}
Lo stato \texttt{GET\_DIM} si preoccupa di aggiornare il segnale \texttt{dim\_address} con l'indirizzo del primo bit libero per la scrittura. Il calcolo che ne determina il valore è: $n\_col \cdot n\_row + 2$.\\
\texttt{GET\_DIM} verifica inoltre il caso speciale in cui una delle dimensioni dovesse essere nulla. In quel caso impone lo stato prossimo a \texttt{DONE}.\\

\textbf{N.B:}\textit{
La moltiplicazione usa segnali \textit{std\_logic\_vector} da $8$ bit e produce un risultato su $16$ bit. Essendo \texttt{dim\_address} un \textit{std\_logic\_vector} su $16$ bit, il problema non si pone.
}

\subsubsection{READ\_PIXEL}
\texttt{READ\_PIXEL} è uno stato strettamente connesso con lo stato \texttt{GET\_MINMAX}. Richiede alla memoria il valore del pixel da leggere e aggiorna il segnale \texttt{curr\_address} a quello successivo. In questo modo il valore del pixel sarà disponibile sul segnale \texttt{i\_data} dopo due \textit{rising\_edge} successivi. L'attesa è sempre lasciata allo stato \texttt{WAIT\_MEM}.

\subsubsection{GET\_MINMAX}
\texttt{GET\_MINMAX} aggiorna i segnali \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value}, inizializzati rispettivamente con $0$ e $255$, con il valore di \texttt{i\_data}. Questo avviene se e solo se si verifica che \texttt{i\_data} è \textit{maggiore} di \texttt{max\_pixel\_value} (in questo caso aggiorna \texttt{max\_pixel\_value}) oppure se \texttt{i\_data} è \textit{minore} di \texttt{min\_pixel\_value} (in questo caso aggiorna \texttt{min\_pixel\_value}). Infine, imposta lo stato prossimo a \texttt{READ\_PIXEL}
%non so perche lo mette in viola

\subsubsection{GET\_DELTA}
\texttt{GET\_DELTA} è uno stato banale. Calcola la \textit{differenza} tra \texttt{max\_pixel\_value} e \texttt{min\_pixel\_value} e imposta lo stato prossimo a \texttt{WAIT\_MEM}.

\pagebreak

\subsubsection{CALC\_SHIFT}
Lo stato \texttt{CALC\_SHIFT} si preoccupa di effettuare la riga $2$ dello speudo-codice riportato al paragrafo $1.2$.
Per effettuare il calcolo, richiama se stesso (attraverso lo stato \texttt{WAIT\_MEM}) aggiornando dei segnali d'appoggio. Nel dettaglio si potrebbe semplificare il tutto con il seguente pseudo-codice:
\\
\\
\noindent\fbox{
\begin{varwidth}{\dimexpr\linewidth-2\fboxsep-2\fboxrule\relax}
\begin{algorithmic}[1]
  \State $m \gets delta\_value+1$
  \State $k \gets -1$
  \State $t \gets 1$
   \While{$t\leq m$}
   \State $k \gets k+1$
       \State $t \gets t*2$
  \EndWhile
  \State $shift\_level \gets 8-k$
\end{algorithmic}
\end{varwidth}
}
\\
\\
\\
Sostanzialmente attraverso il ciclo \texttt{WHILE} si ricava \textit{k}, il quale non è altro che il valore di $\floor{log_2(delta\_value +1)}$. Questa procedura è forse quella più dispendiosa a livello di tempo e memoria, poichè per aggiornare ogni segnale si deve come minimo attendere due cicli di clock. Inoltre, la moltiplicazione tra due interi (\textit{t} e $2$) produce un risultato su $64$ \textit{bit} che VHDL gestisce troncando a $32$ \textit{bit}. Per le specifiche del progetto, ci si aspetta che \textit{k} non possa assumere un valore maggiore di $8$. Pertanto, si è certi che una variabile a $32$ \textit{bit} possa largamente contenere i valori desiderati.

\subsubsection{GET\_PIXEL}
\texttt{GET\_PIXEL} è uno stato omonimo di \texttt{READ\_PIXEL}. La principale differenza del primo con il secondo è che mentre \texttt{READ\_PIXEL} effettua dei controlli sul flusso della computazione, \texttt{GET\_PIXEL} richiede solamente alla memoria il dato da leggere e imposta lo stato prossimo a \texttt{WAIT\_MEM}.

\subsubsection{CALC\_NEWPIXEL}
In \texttt{CALC\_NEWPIXEL} si calcola il nuovo valore del pixel da scrive in memoria.
Per farlo, viene utilizzata una variabile di appoggio \texttt{pixel\_to\_shift} definita come uno \textit{std\_logic\_vector} da $16$ \textit{bit} e inizializzata come $\texttt{i\_data}-\texttt{min\_pixel\_value}$ con l’aggiunta di otto `$0$' in posizione più significativa.
La variabile viene, quindi, shiftata e su di essa viene fatto il seguente controllo: se risulta essere minore di $255$ allora aggiorniamo il segnale \texttt{new\_pixel} al suo valore in \textit{std\_logic\_vector} su $8$ \textit{bit}, altrimenti il segnale \texttt{new\_pixel} viene impostato a $255$ sempre in \textit{std\_logic\_vector} su $8$ \textit{bit}.

\subsubsection{WRITE\_PIXEL}
Lo stato \texttt{WRITE\_PIXEL} si assicura che il valore del nuovo pixel calcolato sia scritto in memoria, incrementa tutti i contatori e controlla di non essere arrivato al termine della computazione. Il controllo usufruisce della varibile intera \texttt{last}, che assume il valore di $2*\texttt{n\_col}*\texttt{n\_row}+2$, ovvero l'indice dell'ultimo pixel scrivibile. Quando il contatore assume questo valore lo stato successivo viene impostato a \texttt{DONE} (sempre attravero \texttt{WAIT\_MEM}), altrimenti viene impostato lo stato prossimo a \texttt{ABILIT\_READ}, dove la scrittura viene disabilitata e viene riabilitata la lettura per il pixel successivo. Anche qui, si noti che il calcolo di \texttt{last} è sicuramente contenibile in una varibile a $32$ \textit{bit}.

\subsubsection{DONE}
\texttt{DONE} chiude tutte le comunicazioni con la memoria, riportando a `$0$' sia \texttt{o\_en} che \texttt{o\_we} e pulendo il buffer di \texttt{o\_address} e \texttt{o\_data}.
Successivamente il segnale \texttt{o\_done} viene portato ad `$1$' e lo stato prossimo è impostato a \texttt{ WAITING\_PIC}.


\subsubsection{WAITINGPIC}
Ultimo stato del processo. Ha lo scopo di restare in attesa che il segnale di \texttt{i\_start} venga riportato a `$0$'. Finche ciò non avviene, \texttt{ WAITING\_PIC} richiama se stesso. Quando sia \texttt{i\_start} che \texttt{o\_done} hanno il segnale a `$0$', imposta lo stato prossimo a \texttt{START} facendo ricominciare l’intera compilazione.

\subsection{Approfondimento sul process STATES}
All'interno del process \texttt{STATES} si possono notare due macro momenti della computazione. Il primo (in rosso sullo schema al paragrafo successivo) è quello descritto dalla prima lettura completa della memoria, attraverso la quale si determinano tutti i valori necessari per la computazione del nuovo pixel. Si noti inoltre che all'interno del primo momento abbiamo due cicli ben distinti: uno per il calcolo del \textit{max\_value} e \textit{min\_value} e uno per il calcolo dello \textit{shift\_level} (rispettivamente in blue e marrone). Il secondo momento (in verde), invece, è descritto dalla seconda lettura semi-completa della memoria (difatto si esclude la lettura dei primi $2$ \textit{byte}) ed è il momento nel quale il pixel appena letto viene rielaborato e salvato in memoria nel \textit{byte} opportuno. Questa doppia lettura della memoria, sebbene aumenti la complessità temporale, è strettamente necessaria, per via del calcolo del \textit{delta}. Iniziamente, si era pensato di ottimizzare il secondo momento con due proeccess paralleli: il primo avrebbe elaborato i pixel pari, mentre il secondo i pixel dispari, e sarebbero stati gestiti da opportuni `semafori'. Tuttavia, la struttura attuale è risultata essere molto più stabile nei test, permettendoci anche di variare a nostra discrezione il tempo di clock della computazione.
\pagebreak

\subsubsection{Schema process STATES}
%FSA
\vspace{0.5 cm}
\begin{center}
\resizebox{!}{24cm}{
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2cm,
        scale = 1,transform shape, on grid]

  \node[state] (start) [scale=1] {$START$};
  \node[state] (init) [below=of start, scale=1]  {$INIT$};
  \node[state] (abilitread) [below= of init, scale=0.5]  {$ABILIT\_READ$};
  \node[state] (getrc) [below=of abilitread, scale=0.8, yshift=-0.5cm]  {$GET\_RC$};
  \node[state] (getdim) [below=of getrc, scale=0.6]  {$GET\_DIM$};
  \node[state] (readpixel) [below=of getdim, scale=0.5]  {$READ\_PIXEL$};
  \node[state] (getminmax) [below =of readpixel, scale=0.5] {$GET\_MINMAX$};
  \node[state] (getdelta) [below =of getminmax, scale=0.5] {$GET\_DELTA$};
  \node[state] (calcshift) [below=of getdelta, scale=0.5]  {$CALC\_SHIFT$};
  \node[state] (getpixel) [below=of calcshift, scale=0.5 ]  {$GET\_PIXEL$};
  \node[state] (calcnewpixel) [below=of getpixel, scale=0.5]  {$CALC\_NEWPIXEL$};
  \node[state] (abilitwrite) [below=of calcnewpixel, scale=0.5, yshift=-1cm]  {$ABILIT\_WRITE$};
  \node[state] (writepixel) [below=of abilitwrite, scale=0.5, yshift=-1cm]  {$WRITE\_PIXEL$};
  \node[state] (done) [below=of writepixel, scale=0.7]  {$DONE$};
  \node[state] (waitingpic) [below=of done, scale=0.6]  {$WAITINGPIC$};
  \node[state] (waitmem) [right=of calcshift, xshift=8cm, scale=1.2]  {$WAIT\_MEM$};

  \draw (start) edge[red] node{} (init)
        (init) edge[red] node{} (abilitread)
        (abilitread) edge[red] node{} (getrc)
        (getrc) edge[bend left, out=60, in=45, looseness=1, red] node{} (waitmem)
        (waitmem) edge[bend right, in=-100, out=200, looseness=2, red] node{} (getrc)
        (getdim) edge[bend left, in=120, red] node{} (waitmem)
        (waitmem) edge[bend right, out=-70, in=-100, red] node{} (getdim)
        (readpixel) edge[bend left, out=50, in=130, blue] node{} (waitmem)
        (waitmem) edge[bend right, out=-30, blue] node{} (getminmax)
        (getminmax) edge[blue] node{} (readpixel)
        (readpixel) edge[bend right=90, red] node{} (getdelta)
        (waitmem) edge [bend right, out=-30, red] node{} (readpixel)
        (getdelta) edge[bend left, red] node{} (waitmem)
        (waitmem) edge[bend right=20, brown] node{} (calcshift)
        (calcshift) edge[bend right=20, brown] node{} (waitmem)
        (calcshift) edge[red] node{} (getpixel)
        (getpixel) edge[bend right, green] node{} (waitmem)
        (waitmem) edge[bend left, out=70, green] node{} (calcnewpixel)
        (calcnewpixel) edge[green] node{} (abilitwrite)
        (abilitwrite) edge[green] node{} (writepixel)
        (writepixel) edge[bend right, in=-80, green] node{} (waitmem)
        (writepixel) edge[bend left, in=140, green] node{} (abilitread)
        (abilitread) edge[bend right, green] node{} (getpixel)
        (waitmem) edge[bend left, out=100, looseness=2, green] node{} (done)
        (done) edge[green] node{} (waitingpic)
        (waitingpic) edge[bend left] node{} (start)
        ;
\end{tikzpicture}
}
\end{center}

\pagebreak


\section{Risultati dei Test}
I test eseguiti sono stati pensati appositamente per evitare eventuali errori di programmazione, cercando di coprire il maggior numero di casi possibili. Per farlo, non solo sono stati creati dei test manualmente (dal \texttt{N.$1$} al \texttt{N.$5$} ), ma si è fatto ricorso sia al linguaggio \texttt{C} sia al linguaggio \texttt{Python} per la creazione di veri e propri generatori di test. Entrambi i generatori sono in grado di creare un numero di immagini (di dimensione diversa) in base alla decisione dell'utente. \\
I test creati dai generatori sono stati a loro volta controllati manualmente. Difatto, dal controllo manuale, è emerso che le funzioni delle librerie randomiche nei due linguaggi, essendo uniformemente distribuite, rendevano praticamente certa la presenza dei valori $0$ e $255$ in una qualsiasi immmagine dalle dimensioni maggiori di 20x20. Immagini che hanno all'interno valori molto distanti tra loro rendono l'equalizzazione dell'immagine inutile. Un \textit{delta} molto grande porta inevitabilmente ad uno \textit{shift} nullo, il che significa che l'immagine non viene equalizzata ma semplicemente copiata. Per evitare, quindi, che i test fossero dei semplici copia-incolla, si è deciso di adottare una distribuzione Gaussiana, avendo così immagini con \textit{shift} di livello $8$ molto più probabili di quelli con \textit{shift} nullo. Dopo questa verifica e vista la semplicità nella scrittura di quest'algoritmo in un linguaggio ad alto livello si è supposta veritiera la correttezza dei test prodotti dai generatori. \\
I test in questione hanno ottenuto i seguenti risultati:
\begin{center}
  \begin{tabular}{|c|l|p{10cm}|r|}
    \hline
    N. &Nome Test & Descrizione & Tempi\\
    \hline
    1 & tb\_2x2.vhd & Test base con una immagine 2x2 & 1487500 ps \\
    \hline
    2 & tb10.vhd & Test con 10 immagini 2x2 o 4x1, con caso particolare immagine con una dimensione nulla. Questo test usa tutti i valori di \textit{shift} possibili.&12392500 ps\\
    \hline
    3 & tb5\_delta.vhd & Test con 5 immagini 3x2 con valori di pixel molto vicini tra loro e caso particolare immagine 1x1. & 23522500 ps\\
    \hline
    4 & tbreset.vhd & Test con 8 immagini 2x2 nel quale viene chiamato il segnale \texttt{i\_rst} a fine di ogni compilazione d'immagine. & 1021300 ps\\
    \hline
    5 & tbAsync.vhd & Test con 8 immagini 2x2 nel quale viene chiamato il segnale \texttt{i\_rst} ogni due o ogni tre immagini. & 1021300 ps\\
    \hline
    6& tb128.vhd & Test con una singola immagine 128x128. Questo test è stato ottenuto con un generatore appositamente creato. & 2212818 ns\\
    \hline
    7 & tbHARD.vhd & Stress test con 100 immagini 128x128 senza chiamata al segnale \texttt{i\_rst}. Questo test è stato ottenuto con un genaratore reso disponibile da \mbox{Davivde Merli} su Github: \mbox{https://github.com/davidemerli/RL-generator-2020-2021.git} & 405796650 ns\\
    \hline
  \end{tabular}
\end{center}

In realtà sono stati fatti ulteriori test, con diverso numero di immagini, di varie dimensioni e con \textit{reset} ``casuale", tuttavia riportare ulteriori test a quelli presentati risulterebbe ridondante.

\begin{center}
  \begin{tikzpicture}
    \draw[step=1cm,gray,very thin] (0,0) grid (6,6);
    \fill[mycolor0] (0,0) rectangle (1,1);
    \fill[mycolor200] (1,0) rectangle (2,1);
    %\node[state] (start) [scale=1] {$START$};
  \end{tikzpicture}
  \hspace{2 cm}
  \begin{tikzpicture}
    \draw[step=1cm,gray,very thin] (0,0) grid (6,6);
  \end{tikzpicture}
\end{center}

\pagebreak
\section{Conclusioni}
Write somenthing here

\end{document}
